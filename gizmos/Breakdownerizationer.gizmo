set cut_paste_input [stack 0]
version 11.3 v5
push $cut_paste_input
NoOp {
 name Breakdownerizationer
 knobChanged "if nuke.thisNode().knob(\"type\").value() == \"Wipe Left-to-Right\":\n    nuke.thisNode().knob(\"chk_white_line\").setVisible(True)\nelse:\n    nuke.thisNode().knob(\"chk_white_line\").setVisible(False)"
 selected true
 xpos -444
 ypos 351
 hide_input true
 addUserKnob {20 Options}
 addUserKnob {26 ""}
 addUserKnob {26 spacer l "" -STARTLINE T " "}
 addUserKnob {26 instructions_01 l "" -STARTLINE T "<b>Usage</b>\n\n<p>1) Set parameters below.\n<br>2) Select your final comp in your Node Graph, followed by the<br>&nbsp;&nbsp;layers you want to break down, in order.\n<br>3) Press the \"Breakdown this Shot!\" button, and watch the magic happen!\n\n<br>"}
 addUserKnob {26 ""}
 addUserKnob {4 type l "Breakdown Type" M {"Wipe Left-to-Right" Dissolve "Slide Layer In, Top-to-Bottom"}}
 addUserKnob {3 frame l "Frame to Breakdown"}
 frame 1001
 addUserKnob {3 rewind_speed l "Rewind Speed"}
 rewind_speed 4
 addUserKnob {26 times_text l "" -STARTLINE T " times"}
 addUserKnob {3 ttime l "Transition Duration"}
 ttime 12
 addUserKnob {26 frames_text l "" -STARTLINE T " frames"}
 addUserKnob {3 ptime l "Pause Duration"}
 ptime 8
 addUserKnob {26 frames_text2 l "" -STARTLINE T " frames"}
 addUserKnob {6 chk_white_line l "Show white line on wipes?" +STARTLINE}
 chk_white_line true
 addUserKnob {26 spacer_01 l "" +STARTLINE T " "}
 addUserKnob {22 go_btn l "Breakdown This Shot!" T "def breakdownerizationer_run():\n    \n    if not nuke.selectedNodes():\n        nuke.message(\"Please select some nodes, starting with your final comp first, followed by the nodes you want to break down\")\n        return\n\n    this_node = nuke.thisNode()\n    \n    # Store all the Breakdown layers in a list.\n    layers = \[]\n    \n    for i in nuke.selectedNodes():\n        layers.append(i)\n    \n    layers.reverse()\n    \n    # Get average position of all selected nodes.\n    xposlist = \[]\n    yposlist = \[]\n    \n    for nodes in layers:\n        xposlist.append(nodes.knob('xpos').value())\n        yposlist.append(nodes.knob('ypos').value())\n    \n    avgxpos = sum(xposlist) / len(xposlist)\n    avgypos = sum(yposlist) / len(yposlist)\n    \n    # Create extra variables to do things later...\n    format_value = layers\[0].knob('format').value()\n    first_frame = layers\[0].knob('first').value()\n    last_frame = layers\[0].knob('last').value()\n    frame_range = last_frame - first_frame\n    breakdown_start = last_frame + (last_frame - nuke.thisNode().knob('frame').value())\n    #+ (int(frame_range / int(this_node.knob('rewind_speed').value())))\n    \n    # Create breakdown Group node, add knobs.\n    grp = nuke.createNode('Group', 'name Breakdownerizationer_Build')\n    grp.knob('xpos').setValue(avgxpos)\n    grp.knob('ypos').setValue(avgypos + 250)\n    \n    if this_node.knob('type').value() == \"Wipe Left-to-Right\":\n    \n        grp.addKnob(nuke.Text_Knob('divider_01', ' '))\n    \n        grp.addKnob(nuke.Boolean_Knob('b_whiteline', 'Show white line on wipes?'))\n        grp.knob('b_whiteline').setValue(int(this_node.knob('chk_white_line').value()))\n    \n        grp.addKnob(nuke.Int_Knob('b_whiteline_width', 'White line width'))\n        grp.knob('b_whiteline_width').setValue(2)\n    \n    grp.addKnob(nuke.Text_Knob('divider_02', ' '))\n    \n    breakdown_type_text = \"<b>Breakdown Type:</b> \" + str(this_node.knob('type').value()) + \"\\n\"\n    grp.addKnob(nuke.Text_Knob('text_type', ' ', breakdown_type_text))\n    grp.addKnob(nuke.Text_Knob('spacer_01', ' ', ' '))\n    \n    # Add knobs and set their values.\n    grp.addKnob(nuke.Int_Knob('num_inputs', 'Number of Inputs'))\n    grp.knob('num_inputs').setValue(int(len(layers)))\n    \n    grp.addKnob(nuke.Int_Knob('b_frame', 'Breakdown Frame'))\n    grp.knob('b_frame').setValue(int(this_node.knob('frame').value()))\n    \n    grp.addKnob(nuke.Int_Knob('b_rSpeed', 'Rewind Speed'))\n    grp.knob('b_rSpeed').setValue(int(this_node.knob('rewind_speed').value()))\n    \n    grp.addKnob(nuke.Int_Knob('b_td', 'Transition Duration'))\n    grp.knob('b_td').setValue(int(this_node.knob('ttime').value()))\n    \n    grp.addKnob(nuke.Int_Knob('b_pause', 'Pause Duration'))\n    grp.knob('b_pause').setValue(int(this_node.knob('ptime').value()))\n    \n    grp.addKnob(nuke.Text_Knob('divider_03', ' '))\n    \n    # Disable the knobs, as they're just for show.\n    grp.knob('num_inputs').setEnabled(False)\n    grp.knob('b_frame').setEnabled(False)\n    grp.knob('b_rSpeed').setEnabled(False)\n    grp.knob('b_td').setEnabled(False)\n    grp.knob('b_pause').setEnabled(False)\n    \n    # Open up the Group to build the dynamic gizmo...\n    grp.begin()\n    \n    # Set variables\n    wipe_time = nuke.thisNode().knob('b_td').value()\n    pause_time = nuke.thisNode().knob('b_pause').value()\n    \n    # Create the first input manually, so we can name it.\n    comp_input = nuke.createNode('Input', \"name comp\")\n    \n    # Create the TimeWarp, that reverses the shot.\n    reverse_time = nuke.createNode('TimeWarp', 'filter nearest')\n    reverse_time_knob = reverse_time.knob('lookup')\n    reverse_time_knob.setAnimated(0)\n    reverse_time_anim = reverse_time_knob.animations()\[0]\n    reverse_time_anim.setKey(last_frame + pause_time, last_frame)\n    reverse_time_anim.setKey(last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value()), nuke.thisNode().knob('b_frame').value())\n    \n    # Switch to the TimeWarp at the right time.\n    switch_node = nuke.createNode('Switch')\n    switch_node.setInput(0, comp_input)\n    switch_node.setInput(1, reverse_time)\n    switch_node.knob('which').setAnimated(0)\n    switchAnim = switch_node.knob('which').animations()\[0]\n    switchAnim.setKey(last_frame - 1 + pause_time, 0)\n    switchAnim.setKey(last_frame + pause_time, 1)\n    \n    prev_merge_node = switch_node\n    \n    if this_node.knob('type').value() == \"Wipe Left-to-Right\":\n    \n        # Create the rest of the inputs, based off the number of selected Read nodes. Then do all the things.\n        for x in range(0, (len(layers) - 1)):\n            nuke.createNode('Input')\n            reformat_node = nuke.createNode('Reformat', 'format format_value')\n            solid_alpha_shuffle = nuke.createNode('Shuffle', 'in alpha out alpha red white')\n            framehold_node = nuke.createNode('FrameHold', 'first_frame b_frame')\n            crop_node = nuke.createNode('Crop')\n    \n            # Create white line\n            all_alpha_shuffle = nuke.createNode('Shuffle', 'red alpha green alpha blue alpha alpha alpha')\n            transform_node = nuke.createNode('Transform')\n            transform_node.knob('translate').setExpression('b_whiteline_width*-1', 0)\n    \n            stencil_node = nuke.createNode('Merge2', 'operation stencil')\n            stencil_node.setInput(0, all_alpha_shuffle)\n            stencil_node.setInput(1, transform_node)\n    \n            merge_white_line = nuke.createNode('Merge2', 'operation over')\n            merge_white_line.knob('disable').setExpression('!b_whiteline')\n            merge_white_line.setInput(0, crop_node)\n            merge_white_line.setInput(1, stencil_node)\n    \n            # Create the wipe animations\n            knob = crop_node.knob('box')\n            knob.setAnimated(2)\n    \n            animKnob = knob.animations()\[0]\n            animKnob.setKey(1 + pause_time + (last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + x * wipe_time + x * pause_time, -0.001 - nuke.thisNode().knob('b_whiteline_width').value())\n            animKnob.setKey(pause_time + (last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + x * wipe_time + x * pause_time + wipe_time, nuke.root()\['format'].value().width())\n    \n            animKnob.setExpression('curve+b_whiteline_width')\n    \n            merge_node = nuke.createNode('Merge2')\n            merge_node.setInput(0, prev_merge_node)\n            merge_node.setInput(1, merge_white_line)\n    \n            prev_merge_node = merge_node\n    \n    \n    \n    \n    \n    elif this_node.knob('type').value() == \"Slide Layer In, Top-to-Bottom\":\n    \n        # Create the rest of the inputs, based off the number of selected Read nodes. Then do all the things.\n        for x in range(0, (len(layers) - 1)):\n            nuke.createNode('Input')\n            reformat_node = nuke.createNode('Reformat', 'format format_value')\n            nuke.createNode('Crop')\n            framehold_node = nuke.createNode('FrameHold', 'first_frame b_frame')\n            transform_node = nuke.createNode('Transform')\n    \n            # Slide the layers into frame with a transform.\n            knob = transform_node.knob('translate')\n            knob.setAnimated(1)\n    \n            animKnob = knob.animations()\[0]\n            animKnob.setKey(1 + pause_time + (last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + x * wipe_time + x * pause_time, nuke.root()\['format'].value().height())\n            animKnob.setKey(pause_time + (last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + x * wipe_time + x * pause_time + wipe_time, 0)\n    \n            merge_node = nuke.createNode('Merge2')\n            merge_node.setInput(0, prev_merge_node)\n            merge_node.setInput(1, transform_node)\n    \n            prev_merge_node = merge_node\n    \n    \n    \n    elif this_node.knob('type').value() == \"Dissolve\":\n    \n        # Create the rest of the inputs, based off the number of selected Read nodes. Then do all the things.\n        for x in range(0, (len(layers) - 1)):\n            nuke.createNode('Input')\n            reformat_node = nuke.createNode('Reformat', 'format format_value')\n            nuke.createNode('Crop')\n            framehold_node = nuke.createNode('FrameHold', 'first_frame b_frame')\n    \n            # Dissolve the layers.\n            dissolve_node = nuke.createNode('Dissolve')\n            dissolve_node.setInput(1, prev_merge_node)\n            dissolve_node.setInput(0, dissolve_node)\n    \n            knob = dissolve_node.knob('which')\n            knob.setAnimated(0)\n    \n            animKnob = knob.animations()\[0]\n            animKnob.setKey(1 + pause_time + (last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + x * wipe_time + x * pause_time, 1)\n            animKnob.setKey(pause_time + (last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + x * wipe_time + x * pause_time + wipe_time, 0)\n    \n            prev_merge_node = dissolve_node\n    \n    \n    \n    else:\n    \n        nuke.message(\"Well shit, you've broken it, and I don't know how. Please shoot me an email to support@benmcewan.com and let me know, so I can fix it!\")\n    \n    breakdown_length = int((last_frame + pause_time + ((last_frame - nuke.thisNode().knob('b_frame').value()) / nuke.thisNode().knob('b_rSpeed').value())) + (len(layers)-1) * wipe_time + (len(layers)-1) * pause_time + wipe_time)\n    \n    # Play out the remainder of the shot after the last wipe\n    playout_node = nuke.createNode('TimeWarp')\n    playout_node.setInput(0, comp_input)\n    playout_knob = playout_node.knob('lookup')\n    playout_knob.setAnimated(0)\n    playout_anim = playout_knob.animations()\[0]\n    playout_anim.setKey(breakdown_length, grp.knob('b_frame').value())\n    playout_anim.setKey(breakdown_length + (last_frame - grp.knob('b_frame').value()), last_frame)\n    \n    # Switch to the TimeWarp at the right time\n    switch_node = nuke.createNode('Switch')\n    switch_node.setInput(0, prev_merge_node)\n    switch_node.setInput(1, playout_node)\n    switch_node.knob('which').setAnimated(0)\n    switchAnim = switch_node.knob('which').animations()\[0]\n    switchAnim.setKey(breakdown_length - 1, 0)\n    switchAnim.setKey(breakdown_length, 1)\n    \n    # We need an output node so we can view the Group...\n    nuke.createNode('Crop')\n    nuke.createNode('Output')\n    \n    # End the adding of stuff to our Group.\n    grp.end()\n    \n    # Connect the newly-created inputs to the relevant read nodes.\n    for y in range(0, len(layers)):\n        grp.setInput(y, layers\[y])\n    \n    # Set the frame range in project settings\n    nuke.root().knob('last_frame').setValue(breakdown_length + (last_frame - grp.knob('b_frame').value()))\n\nbreakdownerizationer_run()" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {20 info l Info}
 addUserKnob {26 ""}
 addUserKnob {26 version_info l "" +STARTLINE T "\nCreated by Ben McEwan\nwww.benmcewan.com\n\nVersion 1.0\nLast Updated: September 18th, 2019\n\n"}
 addUserKnob {22 btn_bug_report l " Report a Bug " T "import webbrowser\nwebbrowser.open(\"mailto:?to=support@benmcewan.com&subject=I found a bug in Breakdownerizationer v1.0\", new=1)\n" +STARTLINE}
 addUserKnob {26 spacer_02 l "" +STARTLINE T " "}
 addUserKnob {26 ""}
}
